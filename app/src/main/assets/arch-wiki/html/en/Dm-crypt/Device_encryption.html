<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8">
<title>dm-crypt/Device encryption - ArchWiki</title>
<link rel="stylesheet" href="../../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<style></style>
<meta name="generator" content="MediaWiki 1.26.4">
<meta name="robots" content="noindex,follow">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Dm-crypt_Device_encryption skin-archlinux action-view">

		<div id="globalWrapper" style="width: 100%">
		<div id="column-content">
			<div id="content" class="mw-body" role="main" style="margin: 2em; margin-bottom: 0">
				<a id="top"></a>
				
				<div class="mw-indicators">
</div>
				<h1 id="firstHeading" class="firstHeading" lang="en">dm-crypt/Device encryption</h1>
				
				<div id="bodyContent" class="mw-body-content">
					<div id="contentSub"><span class="subpages">&lt; <a href="../../en/Dm-crypt.html" title="Dm-crypt">Dm-crypt</a></span></div>
										<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<p><span></span>
Back to <a href="../../en/Dm-crypt.html" title="Dm-crypt">Dm-crypt</a>.
</p>
<p>This section covers how to manually utilize <i>dm-crypt</i> from the command line to encrypt a system. 
</p>
<div id="toc" class="toc">
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Preparation"><span class="tocnumber">1</span> <span class="toctext">Preparation</span></a></li>
<li class="toclevel-1 tocsection-2">
<a href="#Cryptsetup_usage"><span class="tocnumber">2</span> <span class="toctext">Cryptsetup usage</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Cryptsetup_passphrases_and_keys"><span class="tocnumber">2.1</span> <span class="toctext">Cryptsetup passphrases and keys</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4">
<a href="#Encryption_options_with_dm-crypt"><span class="tocnumber">3</span> <span class="toctext">Encryption options with dm-crypt</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Encryption_options_for_LUKS_mode"><span class="tocnumber">3.1</span> <span class="toctext">Encryption options for LUKS mode</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Encryption_options_for_plain_mode"><span class="tocnumber">3.2</span> <span class="toctext">Encryption options for plain mode</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7">
<a href="#Encrypting_devices_with_cryptsetup"><span class="tocnumber">4</span> <span class="toctext">Encrypting devices with cryptsetup</span></a>
<ul>
<li class="toclevel-2 tocsection-8">
<a href="#Encrypting_devices_with_LUKS_mode"><span class="tocnumber">4.1</span> <span class="toctext">Encrypting devices with LUKS mode</span></a>
<ul>
<li class="toclevel-3 tocsection-9">
<a href="#Formatting_LUKS_partitions"><span class="tocnumber">4.1.1</span> <span class="toctext">Formatting LUKS partitions</span></a>
<ul>
<li class="toclevel-4 tocsection-10"><a href="#Using_LUKS_to_format_partitions_with_a_keyfile"><span class="tocnumber">4.1.1.1</span> <span class="toctext">Using LUKS to format partitions with a keyfile</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-11"><a href="#Unlocking.2FMapping_LUKS_partitions_with_the_device_mapper"><span class="tocnumber">4.1.2</span> <span class="toctext">Unlocking/Mapping LUKS partitions with the device mapper</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="#Encrypting_devices_with_plain_mode"><span class="tocnumber">4.2</span> <span class="toctext">Encrypting devices with plain mode</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13">
<a href="#Cryptsetup_actions_specific_for_LUKS"><span class="tocnumber">5</span> <span class="toctext">Cryptsetup actions specific for LUKS</span></a>
<ul>
<li class="toclevel-2 tocsection-14">
<a href="#Key_management"><span class="tocnumber">5.1</span> <span class="toctext">Key management</span></a>
<ul>
<li class="toclevel-3 tocsection-15"><a href="#Adding_LUKS_keys"><span class="tocnumber">5.1.1</span> <span class="toctext">Adding LUKS keys</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="#Removing_LUKS_keys"><span class="tocnumber">5.1.2</span> <span class="toctext">Removing LUKS keys</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-17">
<a href="#Backup_and_restore"><span class="tocnumber">5.2</span> <span class="toctext">Backup and restore</span></a>
<ul>
<li class="toclevel-3 tocsection-18"><a href="#Backup_using_cryptsetup"><span class="tocnumber">5.2.1</span> <span class="toctext">Backup using cryptsetup</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="#Restore_using_cryptsetup"><span class="tocnumber">5.2.2</span> <span class="toctext">Restore using cryptsetup</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#Manual_backup_and_restore"><span class="tocnumber">5.2.3</span> <span class="toctext">Manual backup and restore</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-21">
<a href="#Re-encrypting_devices"><span class="tocnumber">5.3</span> <span class="toctext">Re-encrypting devices</span></a>
<ul>
<li class="toclevel-3 tocsection-22"><a href="#Encrypt_an_unencrypted_filesystem"><span class="tocnumber">5.3.1</span> <span class="toctext">Encrypt an unencrypted filesystem</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#Re-encrypting_an_existing_LUKS_partition"><span class="tocnumber">5.3.2</span> <span class="toctext">Re-encrypting an existing LUKS partition</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-24">
<a href="#Keyfiles"><span class="tocnumber">6</span> <span class="toctext">Keyfiles</span></a>
<ul>
<li class="toclevel-2 tocsection-25">
<a href="#Types_of_keyfiles"><span class="tocnumber">6.1</span> <span class="toctext">Types of keyfiles</span></a>
<ul>
<li class="toclevel-3 tocsection-26"><a href="#passphrase"><span class="tocnumber">6.1.1</span> <span class="toctext">passphrase</span></a></li>
<li class="toclevel-3 tocsection-27"><a href="#randomtext"><span class="tocnumber">6.1.2</span> <span class="toctext">randomtext</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="#binary"><span class="tocnumber">6.1.3</span> <span class="toctext">binary</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-29">
<a href="#Creating_a_keyfile_with_random_characters"><span class="tocnumber">6.2</span> <span class="toctext">Creating a keyfile with random characters</span></a>
<ul>
<li class="toclevel-3 tocsection-30">
<a href="#Storing_the_keyfile_on_a_filesystem"><span class="tocnumber">6.2.1</span> <span class="toctext">Storing the keyfile on a filesystem</span></a>
<ul>
<li class="toclevel-4 tocsection-31"><a href="#Securely_overwriting_stored_keyfiles"><span class="tocnumber">6.2.1.1</span> <span class="toctext">Securely overwriting stored keyfiles</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-32"><a href="#Storing_the_keyfile_in_tmpfs"><span class="tocnumber">6.2.2</span> <span class="toctext">Storing the keyfile in tmpfs</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-33"><a href="#Configuring_LUKS_to_make_use_of_the_keyfile"><span class="tocnumber">6.3</span> <span class="toctext">Configuring LUKS to make use of the keyfile</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#Unlocking_a_secondary_partition_at_boot"><span class="tocnumber">6.4</span> <span class="toctext">Unlocking a secondary partition at boot</span></a></li>
<li class="toclevel-2 tocsection-35">
<a href="#Unlocking_the_root_partition_at_boot"><span class="tocnumber">6.5</span> <span class="toctext">Unlocking the root partition at boot</span></a>
<ul>
<li class="toclevel-3 tocsection-36">
<a href="#With_a_keyfile_stored_on_an_external_media"><span class="tocnumber">6.5.1</span> <span class="toctext">With a keyfile stored on an external media</span></a>
<ul>
<li class="toclevel-4 tocsection-37"><a href="#Configuring_mkinitcpio"><span class="tocnumber">6.5.1.1</span> <span class="toctext">Configuring mkinitcpio</span></a></li>
<li class="toclevel-4 tocsection-38"><a href="#Configuring_the_kernel_parameters"><span class="tocnumber">6.5.1.2</span> <span class="toctext">Configuring the kernel parameters</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-39"><a href="#With_a_keyfile_embedded_in_the_initramfs"><span class="tocnumber">6.5.2</span> <span class="toctext">With a keyfile embedded in the initramfs</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Preparation">Preparation</span></h2>
<p>Before using <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/?name=cryptsetup">cryptsetup</a></span>, always make sure the <code>dm-crypt</code> <a href="../../en/Kernel_modules.html" title="Kernel module" class="mw-redirect">kernel module</a> is loaded.
</p>
<h2><span class="mw-headline" id="Cryptsetup_usage">Cryptsetup usage</span></h2>
<p><i>Cryptsetup</i> is the command line tool to interface with <i>dm-crypt</i> for creating, accessing and managing encrypted devices. The tool was later expanded to support different encryption types that rely on the Linux kernel <b>d</b>evice-<b>m</b>apper and the <b>crypt</b>ographic modules. The most notable expansion was for the Linux Unified Key Setup (LUKS) extension, which stores all of the needed setup information for dm-crypt on the disk itself and abstracts partition and key management in an attempt to improve ease of use. Devices accessed via the device-mapper are called blockdevices. For further information see <a href="../../en/Disk_encryption.html#Block_device_encryption" title="Disk encryption">Disk encryption#Block device encryption</a>. 
</p>
<p>The tool is used as follows: 
</p>
<pre># cryptsetup &lt;OPTIONS&gt; &lt;action&gt; &lt;action-specific-options&gt; &lt;device&gt; &lt;dmname&gt;
</pre>
<p>It has compiled-in defaults for the options and the encryption mode, which will be used if no others are specified on the command line. Have a look at 
</p>
<pre>$ cryptsetup --help 
</pre>
<p>which lists options, actions and the default parameters for the encryption modes in that order. A full list of options can be found on the man page.
Since different parameters are required or optional, depending on encryption mode and action, the following sections point out differences further. Blockdevice encryption is fast, but speed matters a lot too. Since changing an encryption cipher of a blockdevice after setup is difficult, it is important to check <i>dm-crypt</i> performance for the individual parameters in advance: 
</p>
<pre>$ cryptsetup benchmark 
</pre>
<p>can give guidance on deciding for an algorithm and key-size prior to installation. If certain AES ciphers excel with a considerable higher throughput, these are probably the ones with hardware support in the CPU.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;">
<strong> Tip: </strong>You may want to practise encrypting a virtual hard drive in a <a href="../../en/Category:Virtualization.html" title="Category:Virtualization">virtual machine</a> when learning.</div>
<h3><span class="mw-headline" id="Cryptsetup_passphrases_and_keys">Cryptsetup passphrases and keys</span></h3>
<p>An encrypted blockdevice is protected by a key. A key is either: 
</p>
<ul>
<li> a passphrase: see <a href="../../en/Disk_encryption.html#Choosing_a_strong_passphrase" title="Disk encryption">Disk encryption#Choosing a strong passphrase</a>.</li>
<li> a keyfile, see <a href="#Keyfiles">#Keyfiles</a>.</li>
</ul>
<p>Both key types have default maximum sizes: passphrases can be up to 512 characters and keyfiles up to 8192kiB. 
</p>
<p>An important distinction of <i>LUKS</i> to note at this point is that the key is used to unlock the master-key of a LUKS-encrypted device and can be changed with root access. Other encryption modes do not support changing the key after setup, because they do not employ a master-key for the encryption. See <a href="../../en/Disk_encryption.html#Block_device_encryption" title="Disk encryption">Disk encryption#Block device encryption</a> for details.
</p>
<h2><span class="mw-headline" id="Encryption_options_with_dm-crypt">Encryption options with dm-crypt</span></h2>
<p><i>Cryptsetup</i> supports different encryption operating modes to use with <i>dm-crypt</i>. The most common (and default) is 
</p>
<ul><li>
<code>--type LUKS</code> </li></ul>
<p>The other ones are 
</p>
<ul>
<li>
<code>--type plain</code> for using dm-crypt plain mode,  </li>
<li>
<code>--type loopaes</code> for a loopaes legacy mode, and </li>
<li>
<code>--type tcrypt</code> for a <a href="../../en/TrueCrypt.html" title="Truecrypt" class="mw-redirect">Truecrypt</a> compatibility mode.  </li>
</ul>
<p>The basic cryptographic options for encryption cipher and hashes available can be used for all modes and rely on the kernel cryptographic backend features. All that are loaded at runtime can be viewed with 
</p>
<pre>$ less /proc/crypto 
</pre>
<p>and are available to use as options. If the list is short, execute <code>cryptsetup benchmark</code> which will trigger loading available modules. 
</p>
<p>The following introduces encryption options for the first two modes. Note that the tables list options used in the respective examples in this article and not all available ones. 
</p>
<h3><span class="mw-headline" id="Encryption_options_for_LUKS_mode">Encryption options for LUKS mode</span></h3>
<p>The <i>cryptsetup</i> action to set up a new dm-crypt device in LUKS encryption mode is <i>luksFormat</i>. Unlike the name implies, it does not format the device, but sets up the LUKS device header and encrypts the master-key with the desired cryptographic options. 
</p>
<p>As LUKS is the default encryption mode,
</p>
<pre># cryptsetup -v luksFormat <i>device</i>
</pre>
<p>is all that is needed to create a new LUKS device with default parameters (<code>-v</code> is optional). For comparison, we can specify the default options manually too:  
</p>
<pre># cryptsetup -v --cipher aes-xts-plain64 --key-size 256 --hash sha256 --iter-time 2000 --use-urandom --verify-passphrase luksFormat <i>device</i>
</pre>
<p>Defaults are compared with a cryptographically higher specification example in the table below, with accompanying comments: 
</p>
<table class="wikitable">
<tr>
<th scope="col" style="text-align:left"> Options
</th>
<th scope="col" style="text-align:left"> Cryptsetup 1.7.0 defaults
</th>
<th scope="col" style="text-align:left"> Example
</th>
<th scope="col" style="text-align:left"> Comment
</th>
</tr>
<tr>
<th scope="row" style="text-align:right"> --cipher, -c
</th>
<td> <code>aes-xts-plain64</code>
</td>
<td> <code>aes-xts-plain64</code>
</td>
<td> <a rel="nofollow" class="external text" href="https://www.kernel.org/pub/linux/utils/cryptsetup/v1.6/v1.6.0-ReleaseNotes">Release 1.6.0</a> changed the defaults to an AES <a href="../../en/Disk_encryption.html#Ciphers_and_modes_of_operation" title="Disk encryption">cipher</a> in <a href="https://en.wikipedia.org/wiki/Disk_encryption_theory#XEX-based_tweaked-codebook_mode_with_ciphertext_stealing_.28XTS.29" class="extiw" title="wikipedia:Disk encryption theory">XTS</a> mode (see item 5.16 <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions#5-security-aspects">of the FAQ</a>). It is advised against using the previous default <code>--cipher aes-cbc-essiv</code> because of its known <a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Disk_encryption_theory#Cipher-block_chaining_.28CBC.29">issues</a> and practical <a rel="nofollow" class="external text" href="http://www.jakoblell.com/blog/2013/12/22/practical-malleability-attack-against-cbc-encrypted-luks-partitions/">attacks</a> against them.
</td>
</tr>
<tr>
<th scope="row" style="text-align:right"> --key-size, -s
</th>
<td> <code>256</code>
</td>
<td> <code>512</code>
</td>
<td> By default a 256 bit key-size is used. Note however that <a href="https://en.wikipedia.org/wiki/Disk_encryption_theory#XEX-based_tweaked-codebook_mode_with_ciphertext_stealing_.28XTS.29" class="extiw" title="wikipedia:Disk encryption theory">XTS splits the supplied key in half</a>, so to use AES-256 instead of AES-128 you have to set the XTS key-size to <code>512</code>.
</td>
</tr>
<tr>
<th scope="row" style="text-align:right"> --hash, -h
</th>
<td> <code>sha256</code>
</td>
<td> <code>sha512</code>
</td>
<td> Hash algorithm used for <a href="../../en/Disk_encryption.html#Cryptographic_metadata" title="Disk encryption">key derivation</a>. Release 1.7.0 changed defaults from <code>sha1</code> to <code>sha256</code> "<i>not for security reasons [but] mainly to prevent compatibility problems on hardened systems where SHA1 is already [being] phased out</i>"<a rel="nofollow" class="external autonumber" href="https://www.kernel.org/pub/linux/utils/cryptsetup/v1.7/v1.7.0-ReleaseNotes">[1]</a>. The former default of <code>sha1</code> can still be used for compatibility with older versions of <i>cryptsetup</i> since it is <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions#5-security-aspects">considered secure</a> (see item 5.20).
</td>
</tr>
<tr>
<th scope="row" style="text-align:right"> --iter-time, -i
</th>
<td> <code>2000</code>
</td>
<td> <code>5000</code>
</td>
<td> Number of milliseconds to spend with PBKDF2 passphrase processing. Release 1.7.0 changed defaults from <code>1000</code> to <code>2000</code> to "<i>try to keep PBKDF2 iteration count still high enough and also still acceptable for users.</i>"<a rel="nofollow" class="external autonumber" href="https://www.kernel.org/pub/linux/utils/cryptsetup/v1.7/v1.7.0-ReleaseNotes">[2]</a>. This option is only relevant for LUKS operations that set or change passphrases, such as <i>luksFormat</i> or <i>luksAddKey</i>. Specifying 0 as parameter selects the compiled-in default..
</td>
</tr>
<tr>
<th scope="row" style="text-align:right"> --use-{u,}random
</th>
<td> <code>--use-urandom</code>
</td>
<td> <code>--use-random</code>
</td>
<td> Selects which <a href="../../en/Random_number_generation.html" title="Random number generator" class="mw-redirect">random number generator</a> to use. Quoting the cryptsetup manual page: "In a low-entropy situation (e.g. in an embedded system), both  selections are problematic. Using /dev/urandom can lead to weak keys. Using /dev/random can block a long time, potentially forever, if not enough entropy can be harvested  by the kernel."
</td>
</tr>
<tr>
<th scope="row" style="text-align:right"> --verify-passphrase, -y
</th>
<td> Yes
</td>
<td> -
</td>
<td> Default only for luksFormat and luksAddKey. No need to type for Arch Linux with LUKS mode at the moment.
</td>
</tr>
</table>
<p>If you want to deep-dive into cryptographic features of LUKS, the <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/Specification">LUKS specification</a> (e.g. its appendices) is a resource. 
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;">
<strong> Tip: </strong>It is anticipated that the LUKS header receives another major revision in due course. If you are interested in the plans, the developers' <a rel="nofollow" class="external text" href="https://mbroz.fedorapeople.org/talks/DevConf2016/devconf2016-luks2.pdf">devconfcz2016</a> (pdf) presentation summarizes.</div>
<h3><span class="mw-headline" id="Encryption_options_for_plain_mode">Encryption options for plain mode</span></h3>
<p>In dm-crypt <i>plain</i> mode, there is no master-key on the device, hence, there is no need to set it up. Instead the encryption options to be employed are used directly to create the mapping between an encrypted disk and a named device. The mapping can be created against a partition or a full device. In the latter case not even a partition table is needed.  
</p>
<p>To create a <i>plain</i> mode mapping with cryptsetup's default parameters: 
</p>
<pre># cryptsetup &lt;options&gt; open --type plain &lt;device&gt; &lt;dmname&gt;
</pre>
<p>Executing it will prompt for a password, which should have very high entropy. 
Below a comparison of default parameters with the example in <a href="../../en/Dm-crypt/Encrypting_an_entire_system.html#Plain_dm-crypt" title="Dm-crypt/Encrypting an entire system">Dm-crypt/Encrypting an entire system#Plain dm-crypt</a>
</p>
<table class="wikitable">
<tr>
<th> Option </th>
<th> Cryptsetup 1.7.0 defaults </th>
<th> Example </th>
<th> Comment
</th>
</tr>
<tr>
<td> <b>--hash</b> </td>
<td> <code>ripemd160</code> </td>
<td> - </td>
<td> The hash is used to create the key from the passphrase; it is not used on a keyfile.
</td>
</tr>
<tr>
<td> <b>--cipher</b>
</td>
<td> <code>aes-cbc-essiv:sha256</code>
</td>
<td> <code>twofish-xts-plain64</code> </td>
<td> The cipher consists of three parts: cipher-chainmode-IV generator. Please see <a href="../../en/Disk_encryption.html#Ciphers_and_modes_of_operation" title="Disk encryption">Disk encryption#Ciphers and modes of operation</a> for an explanation of these settings, and the <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/DMCrypt">DMCrypt documentation</a> for some of the options available.
</td>
</tr>
<tr>
<td> <b>--key-size</b>
</td>
<td><code>256</code></td>
<td><code>512</code></td>
<td>The key size (in bits). The size will depend on the cipher being used and also the chainmode in use. Xts mode requires twice the key size of cbc.
</td>
</tr>
<tr>
<td> <b>--offset</b>
</td>
<td><code>0</code></td>
<td><code>0</code></td>
<td>The offset from the beginning of the target disk (in bytes) from which to start the mapping
</td>
</tr>
<tr>
<td> <b>--key-file</b>
</td>
<td>default uses a passphrase</td>
<td>
<code>/dev/sd<i>Z</i></code> (or e.g. /boot/keyfile.enc)</td>
<td>The device or file to be used as a key. See <a href="#Keyfiles">#Keyfiles</a> for further details.
</td>
</tr>
<tr>
<td> <b>--keyfile-offset</b>
</td>
<td><code>0</code></td>
<td><code>0</code></td>
<td>Offset from the beginning of the file where the key starts (in bytes). This option is supported from <i>cryptsetup</i> 1.6.7 onwards.
</td>
</tr>
<tr>
<td> <b>--keyfile-size</b>
</td>
<td><code>8192kB</code></td>
<td>- (default applies)</td>
<td>Limits the bytes read from the key file. This option is supported from <i>cryptsetup</i> 1.6.7 onwards.
</td>
</tr>
</table>
<p>Using the device <code>/dev/sd<i>X</i></code>, the above right column example results in:
</p>
<pre># cryptsetup --cipher=twofish-xts-plain64 --offset=0 --key-file=/dev/sd<i>Z</i> --key-size=512 open --type=plain /dev/sdX enc</pre>
<p>Unlike encrypting with LUKS, the above command must be executed <i>in full</i> whenever the mapping needs to be re-established, so it is important to remember the cipher, hash and key file details.
We can now check that the mapping has been made:
</p>
<pre># fdisk -l
</pre>
<p>An entry should now exist for <code>/dev/mapper/enc</code>.
</p>
<h2><span class="mw-headline" id="Encrypting_devices_with_cryptsetup">Encrypting devices with cryptsetup</span></h2>
<p>This section shows how to employ the options for creating new encrypted blockdevices and accessing them manually. 
</p>
<h3><span class="mw-headline" id="Encrypting_devices_with_LUKS_mode">Encrypting devices with LUKS mode</span></h3>
<h4><span class="mw-headline" id="Formatting_LUKS_partitions">Formatting LUKS partitions</span></h4>
<p>In order to setup a partition as an encrypted LUKS partition execute:
</p>
<pre># cryptsetup luksFormat <i>device</i>
</pre>
<p>You will then be prompted to enter a password and verify it.
</p>
<p>See <a href="#Encryption_options_for_LUKS_mode">#Encryption options for LUKS mode</a> for command line options.
</p>
<p>You can check the results with:
</p>
<pre># cryptsetup luksDump <i>device</i>
</pre>
<p>You will note that the dump not only shows the cipher header information, but also the key-slots in use for the LUKS partition.  
</p>
<p>The following example will create an encrypted root partition on <code>/dev/sda1</code> using the default AES cipher in XTS mode with an effective 256-bit encryption 
</p>
<pre># cryptsetup -s 512 luksFormat /dev/sda1</pre>
<h5><span class="mw-headline" id="Using_LUKS_to_format_partitions_with_a_keyfile">Using LUKS to format partitions with a keyfile</span></h5>
<p>When creating a new LUKS encrypted partition, a keyfile may be associated with the partition on its creation using:
</p>
<pre># cryptsetup luksFormat <i>device</i> <i>/path/to/mykeyfile</i>
</pre>
<p>This is accomplished by appending the bold area to the standard cryptsetup command which defines where the keyfile is located.
</p>
<p>See <a href="#Keyfiles">#Keyfiles</a> for instructions on how to generate and manage keyfiles.
</p>
<h4><span class="mw-headline" id="Unlocking.2FMapping_LUKS_partitions_with_the_device_mapper">Unlocking/Mapping LUKS partitions with the device mapper</span></h4>
<p>Once the LUKS partitions have been created, they can then be unlocked.
</p>
<p>The unlocking process will map the partitions to a new device name using the device mapper. This alerts the kernel that <code><i>device</i></code> is actually an encrypted device and should be addressed through LUKS using the <code>/dev/mapper/<i>dm_name</i></code> so as not to overwrite the encrypted data. To guard against accidental overwriting, read about the possibilities to <a href="../../en/Dm-crypt/Device_encryption.html#Backup_and_restore" title="Dm-crypt/Device encryption">backup the cryptheader</a> after finishing setup.
</p>
<p>In order to open an encrypted LUKS partition execute:
</p>
<pre># cryptsetup open --type luks <i>device</i> <i>dm_name</i>
</pre>
<p>You will then be prompted for the password to unlock the partition. Usually the device mapped name is descriptive of the function of the partition that is mapped. For example the following unlocks a luks partition <code>/dev/sda1</code> and maps it to device mapper named <code>cryptroot</code>:
</p>
<pre># cryptsetup open --type luks /dev/sda1 cryptroot 
</pre>
<p>Once opened, the root partition device address would be <code>/dev/mapper/cryptroot</code> instead of the partition (e.g. <code>/dev/sda1</code>). 
</p>
<p>For setting up LVM ontop the encryption layer the device file for the decrypted volume group would be anything like <code>/dev/mapper/cryptroot</code> instead of <code>/dev/sda1</code>. LVM will then give additional names to all logical volumes created, e.g. <code>/dev/mapper/lvmpool-root</code> and <code>/dev/mapper/lvmpool-swap</code>.
</p>
<p>In order to write encrypted data into the partition it must be accessed through the device mapped name. The first step of access will typically be to <a href="../../en/File_systems.html#Formatting" title="File systems">create a filesystem</a>. For example:
</p>
<pre># mkfs -t ext4 /dev/mapper/cryptroot
</pre>
<p>The device <code>/dev/mapper/cryptroot</code> can then be <a href="../../en/File_systems.html#Mount_a_file_system" title="Mount" class="mw-redirect">mounted</a> like any other partition.
</p>
<p>To close the luks container, unmount the partition and do:
</p>
<pre># cryptsetup close cryptroot
</pre>
<h3><span class="mw-headline" id="Encrypting_devices_with_plain_mode">Encrypting devices with plain mode</span></h3>
<p>The creation and subsequent access of a <i>dm-crypt</i> plain mode encryption both require not more than using the <i>cryptsetup</i> <code>open</code> action with correct <a href="../../en/Dm-crypt/Device_encryption.html#Encryption_options_for_plain_mode" title="Dm-crypt/Device encryption">parameters</a>. The following shows that with two examples of non-root devices, but adds a quirk by stacking both (i.e. the second is created inside the first). Obviously, stacking the encryption doubles overhead. The usecase here is simply to illustrate another example of the cipher option usage. 
</p>
<p>A first mapper is created with <i>cryptsetup's</i> plain-mode defaults, as described in the table's left column above  
</p>
<pre># cryptsetup --type plain -v open /dev/sdaX plain1 
Enter passphrase: 
Command successful.
# 
</pre>
<p>Now we add the second blockdevice inside it, using different encryption parameters and with an (optional) offset, create a filesystem and mount it  
</p>
<pre># cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10  open /dev/mapper/plain1 plain2
Enter passphrase: 
# lsblk -p   
NAME                                                     
/dev/sda                                     
├─/dev/sdaX          
│ └─/dev/mapper/plain1     
│   └─/dev/mapper/plain2              
...
# mkfs -t ext2 /dev/mapper/plain2
# mount -t ext2 /dev/mapper/plain2 /mnt
# echo "This is stacked. one passphrase per foot to shoot." &gt; /mnt/stacked.txt
</pre>
<p>We close the stack to check access works
</p>
<pre># cryptsetup close plain2
# cryptsetup close plain1
</pre>
<p>First, let's try to open the filesystem directly: 
</p>
<pre># cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10 open /dev/sdaX plain2
# mount -t ext2 /dev/mapper/plain2 /mnt
mount: wrong fs type, bad option, bad superblock on /dev/mapper/plain2,
      missing codepage or helper program, or other error
</pre>
<p>Why that did not work? Because the "plain2" starting block (10) is still encrypted with the cipher from "plain1". It can only be accessed via the stacked mapper. The error is arbitrary though, trying a wrong passphrase or wrong options will yield the same. For <i>dm-crypt</i> plain mode, the <code>open</code> action will not error out itself.  
</p>
<p>Trying again in correct order: 
</p>
<pre># cryptsetup close plain2    # dysfunctional mapper from previous try
# cryptsetup --type plain open /dev/sdaX plain1
Enter passphrase: 
# cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10 open /dev/mapper/plain1 plain2 
Enter passphrase: 
# mount /dev/mapper/plain2 /mnt &amp;&amp; cat /mnt/stacked.txt
This is stacked. one passphrase per foot to shoot.
# exit
</pre>
<p><i>dm-crypt</i> will handle stacked encryption with some mixed modes too. For example LUKS mode could be stacked on the "plain1" mapper. Its header would then be encrypted inside "plain1" when that is closed.
</p>
<p>Available for plain mode only is the option <code>--shared</code>. With it a single device can be segmented into different non-overlapping mappers. We do that in the next example, using a <i>loopaes</i> compatible cipher mode for "plain2" this time: 
</p>
<pre># cryptsetup --type plain --offset 0 --size 1000 open /dev/sdaX plain1 
Enter passphrase: 
# cryptsetup --type plain --offset 1000 --size 1000 --shared --cipher=aes-cbc-lmk --hash=sha256 open /dev/sdaX plain2
Enter passphrase: 
# lsblk -p
NAME                    
dev/sdaX                    
├─/dev/sdaX               
│ ├─/dev/mapper/plain1     
│ └─/dev/mapper/plain2     
...
</pre>
<p>As the devicetree shows both reside on the same level, i.e. are not stacked and "plain2" can be opened individually.
</p>
<h2><span class="mw-headline" id="Cryptsetup_actions_specific_for_LUKS">Cryptsetup actions specific for LUKS</span></h2>
<h3><span class="mw-headline" id="Key_management">Key management</span></h3>
<p>It is possible to define up to 8 different keys per LUKS partition. This enables the user to create access keys for save backup storage: In a so-called key escrow, one key is used for daily usage, another kept in escrow to gain access to the partition in case the daily passphrase is forgotten or a keyfile is lost/damaged. Also a different key-slot could be used to grant access to a partition to a user by issuing a second key and later revoking it again. 
</p>
<p>Once an encrypted partition has been created, the initial keyslot 0 is created (if no other was specified manually). Additional keyslots are numbered from 1 to 7. Which keyslots are used can be seen by issuing 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksDump /dev/&lt;device&gt; |grep BLED</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
Key Slot 0: ENABLED
Key Slot 1: ENABLED
Key Slot 2: ENABLED
Key Slot 3: DISABLED
Key Slot 4: DISABLED
Key Slot 5: DISABLED
Key Slot 6: DISABLED
Key Slot 7: DISABLED</pre>
<p>Where &lt;device&gt; is the volume containing the LUKS header. This and all the following commands in this section work on header backup files as well. 
</p>
<h4><span class="mw-headline" id="Adding_LUKS_keys">Adding LUKS keys</span></h4>
<p>Adding new keyslots is accomplished using cryptsetup with the <code>luksAddKey</code> action. For safety it will always, i.e. also for already unlocked devices, ask for a valid existing key ("any passphrase") before a new one may be entered:
</p>
<pre># cryptsetup luksAddKey /dev/&lt;device&gt; (/path/to/&lt;additionalkeyfile&gt;) 
Enter any passphrase:
Enter new passphrase for key slot:
Verify passphrase: 
</pre>
<p>If <code>/path/to/&lt;additionalkeyfile&gt;</code> is given, cryptsetup will add a new keyslot for &lt;additionalkeyfile&gt;. Otherwise a new passphrase will be prompted for twice. For using an existing <i>keyfile</i> to authorize the action, the <code>--key-file</code> or <code>-d</code> option followed by the "old" &lt;keyfile&gt; will try to unlock all available keyfile keyslots:
</p>
<pre># cryptsetup luksAddKey /dev/&lt;device&gt; (/path/to/&lt;additionalkeyfile&gt;) -d /path/to/&lt;keyfile&gt;
</pre>
<p>If it is intended to use multiple keys and change or revoke them, the <code>--key-slot</code> or <code>-S</code> option may be used to specify the slot: 
</p>
<pre># cryptsetup luksAddKey /dev/&lt;device&gt; -S 6 
Enter any passphrase: 
Enter new passphrase for key slot: 
Verify passphrase:
# cryptsetup luksDump /dev/sda8 |grep 'Slot 6'
Key Slot 6: ENABLED
</pre>
<p>To show an associated action in this example, we decide to change the key right away:  
</p>
<pre># cryptsetup luksChangeKey /dev/&lt;device&gt; -S 6 
Enter LUKS passphrase to be changed: 
Enter new LUKS passphrase: 
</pre>
<p>before continuing to remove it.
</p>
<h4><span class="mw-headline" id="Removing_LUKS_keys">Removing LUKS keys</span></h4>
<p>There are three different actions to remove keys from the header: 
</p>
<ul>
<li>
<code>luksRemoveKey</code> is used to remove a key by specifying its passphrase/key-file.  </li>
<li>
<code>luksKillSlot</code> may be used to remove a key from a specific key slot (using another key). Obviously, this is extremely useful if you have forgotten a passphrase, lost a key-file, or have no access to it. </li>
<li>
<code>luksErase</code> is used to quickly remove <b>all</b> active keys. </li>
</ul>
<div style="padding: 5px; margin: 0.50em 0; background-color: #FFDDDD; border: thin solid #DDBBBB; overflow: hidden;">
<strong> Warning: </strong>
<ul>
<li>All above actions can be used to irrevocably delete the last active key for an encrypted device! </li>
<li>The <code>luksErase</code> command was added in version 1.6.4 to quickly nuke access to the device. This action <b>will not</b> prompt for a valid passphrase! It will not <a href="../../en/Dm-crypt/Drive_preparation.html#Wipe_LUKS_header" title="Dm-crypt/Drive preparation">wipe the LUKS header</a>, but all keyslots at once and you will, therefore, not be able to regain access unless you have a valid backup of the LUKS header.</li>
</ul>
</div> 
<p>For above warning it is good to know the key we want to <b>keep</b> is valid. An easy check is to unlock the device with the <code>-v</code> option, which will specify which slot it occupies:  
</p>
<pre># cryptsetup -v open /dev/&lt;device&gt; testcrypt
Enter passphrase for /dev/&lt;device&gt;: 
Key slot 1 unlocked.
Command successful.</pre>
<p>Now we can remove the key added in the previous subsection using its passphrase: 
</p>
<pre># cryptsetup luksRemoveKey /dev/&lt;device&gt;
Enter LUKS passphrase to be deleted: 
</pre>
<p>If we had used the same passphrase for two keyslots, the first slot would be wiped now. Only executing it again would remove the second one. 
</p>
<p>Alternatively, we can specify the key slot: 
</p>
<pre># cryptsetup luksKillSlot /dev/&lt;device&gt; 6
Enter any remaining LUKS passphrase:
</pre>
<p>Note that in both cases, no confirmation was required.
</p>
<pre># cryptsetup luksDump /dev/sda8 |grep 'Slot 6'
Key Slot 6: DISABLED
</pre>
<p>To re-iterate the warning above: If the same passphrase had been used for key slots 1 and 6, both would be gone now.
</p>
<h3><span class="mw-headline" id="Backup_and_restore">Backup and restore</span></h3>
<p>If the header of a LUKS encrypted partition gets destroyed, you will not be able to decrypt your data. It is just as much of a dilemma as forgetting the passphrase or damaging a key-file used to unlock the partition. Damage may occur by your own fault while re-partitioning the disk later or by third-party programs misinterpreting the partition table. Therefore, having a backup of the header and storing it on another disk might be a good idea.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDDDFF; border: thin solid #BBBBDD; overflow: hidden;">
<strong> Note: </strong>If the LUKS-encrypted  partitions' master passphrase becomes compromised, you must revoke it on <i>every</i> copy of the cryptheader, even those you have backed up. Otherwise, a copy of the backed-up cryptheader that uses the compromised passphrase can be used to decrypt the associated partition. See <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions#6-backup-and-data-recovery">LUKS FAQ</a> for further details.</div>
<h4><span class="mw-headline" id="Backup_using_cryptsetup">Backup using cryptsetup</span></h4>
<p>Cryptsetup's <code>luksHeaderBackup</code> action stores a binary backup of the LUKS header and keyslot area:
</p>
<pre># cryptsetup luksHeaderBackup /dev/&lt;device&gt; --header-backup-file /mnt/&lt;backup&gt;/&lt;file&gt;.img
</pre>
<p>where &lt;device&gt; is the partition containing the LUKS volume.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;">
<strong> Tip: </strong>You can also back up the plaintext header into ramfs and encrypt it in example with gpg before writing to persistent backup storage by executing the following commands.</div>
<pre># mkdir /root/&lt;tmp&gt;/
# mount ramfs /root/&lt;tmp&gt;/ -t ramfs
# cryptsetup luksHeaderBackup /dev/&lt;device&gt; --header-backup-file /root/&lt;tmp&gt;/&lt;file&gt;.img
# gpg2 --recipient &lt;User ID&gt; --encrypt /root/&lt;tmp&gt;/&lt;file&gt;.img 
# cp /root/&lt;tmp&gt;/&lt;file&gt;.img.gpg /mnt/&lt;backup&gt;/
# umount /root/&lt;tmp&gt;</pre>
<div style="padding: 5px; margin: 0.50em 0; background-color: #FFDDDD; border: thin solid #DDBBBB; overflow: hidden;">
<strong> Warning: </strong>Tmpfs can swap to harddisk if low on memory so it is not recommended here.</div>
<h4><span class="mw-headline" id="Restore_using_cryptsetup">Restore using cryptsetup</span></h4>
<div style="padding: 5px; margin: 0.50em 0; background-color: #FFDDDD; border: thin solid #DDBBBB; overflow: hidden;">
<strong> Warning: </strong>Restoring the wrong header or restoring to an unencrypted partition will cause data loss! The action can not perform a check whether the header is actually the <i>correct</i> one for that particular device.</div> 
<p>In order to evade restoring a wrong header, you can ensure it does work by using it as a remote <code>--header</code> first: 
</p>
<pre># cryptsetup -v --header /mnt/&lt;backup&gt;/&lt;file&gt;.img open /dev/&lt;device&gt; test 
Key slot 0 unlocked.
Command successful.
# mount /dev/mapper/test /mnt/test &amp;&amp; ls /mnt/test 
# umount /mnt/test 
# cryptsetup close test 
</pre>
<p>Now that the check succeeded, the restore may be performed: 
</p>
<pre># cryptsetup luksHeaderRestore /dev/&lt;device&gt; --header-backup-file ./mnt/&lt;backup&gt;/&lt;file&gt;.img
</pre>
<p>Now that all the keyslot areas are overwritten; only active keyslots from the backup file are available after issuing the command.
</p>
<h4><span class="mw-headline" id="Manual_backup_and_restore">Manual backup and restore</span></h4>
<p>The header always resides at the beginning of the device and a backup can be performed without access to <i>cryptsetup</i> as well. First you have to find out the payload offset of the crypted partition:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksDump /dev/&lt;device&gt; | grep "Payload offset"</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
 Payload offset:	4040</pre>
<p>Second check the sector size of the drive
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># fdisk -l /dev/&lt;device&gt; |grep "Sector size"</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Sector size (logical/physical): 512 bytes / 512 bytes</pre>
<p>Now that you know the values, you can backup the header with a simple dd command:
</p>
<pre># dd if=/dev/&lt;device&gt; of=/path/to/&lt;file&gt;.img bs=512 count=4040
</pre>
<p>and store it safely.
</p>
<p>A restore can then be performed using the same values as when backing up:
</p>
<pre># dd if=./&lt;file&gt;.img of=/dev/&lt;device&gt; bs=512 count=4040
</pre>
<h3><span class="mw-headline" id="Re-encrypting_devices">Re-encrypting devices</span></h3>
<p>The <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/?name=cryptsetup">cryptsetup</a></span> package features the <i>cryptsetup-reencrypt</i> tool. It can be used to convert an existing unencrypted filesystem to a LUKS encrypted one (option <code>--new</code>) and permanently remove LUKS encryption (<code>--decrypt</code>) from a device. As its name suggests it can also be used to re-encrypt an existing LUKS encrypted device, though, re-encryption is not possible for a detached LUKS header or other encryption modes (e.g. plain-mode). For re-encryption it is possible to change the <a href="#Encryption_options_for_LUKS_mode">#Encryption options for LUKS mode</a>. <i>cryptsetup-reencrypt</i> actions can be performed to unmounted devices only.  See <code>man cryptsetup-reencrypt</code> for more information. 
</p>
<p>One application of re-encryption may be to secure the data again after a passphrase or <a href="#Keyfiles">keyfile</a> has been compromised <i>and</i> one cannot be certain that no copy of the LUKS header has been obtained. For example, if only a passphrase has been shoulder-surfed but no physical/logical access to the device happened, it would be enough to change the respective passphrase/key only (<a href="#Key_management">#Key management</a>). 
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #FFDDDD; border: thin solid #DDBBBB; overflow: hidden;">
<strong> Warning: </strong>Always make sure a <b>reliable backup</b> is available and double-check options you specify before using the tool!</div>
<p>The following shows an example to encrypt an unencrypted filesystem partition and a re-encryption of an existing LUKS device. 
</p>
<h4><span class="mw-headline" id="Encrypt_an_unencrypted_filesystem">Encrypt an unencrypted filesystem</span></h4>
<p>A LUKS encryption header is always stored at the beginning of the device. Since an existing filesystem will usually be allocated all partition sectors, the first step is to shrink it to make space for the LUKS header. 
</p>
<p>The <a href="#Encryption_options_for_LUKS_mode">default</a> LUKS header encryption cipher requires <code>4096</code> 512-byte sectors. We already checked space and keep it simple by shrinking the existing <code>ext4</code> filesystem on <code>/dev/sdaX</code> to its current possible minimum: 
</p>
<pre># umount /mnt
# e2fsck -f /dev/sdaX 
e2fsck 1.43-WIP (18-May-2015)
Pass 1: Checking inodes, blocks, and sizes
...
/dev/sda6: 12/166320 files (0.0% non-contiguous), 28783/665062 blocks
# resize2fs -M /dev/sdaX
resize2fs 1.43-WIP (18-May-2015)
Resizing the filesystem on /dev/sdaX to 26347 (4k) blocks.
The filesystem on /dev/sdaX is now 26347 (4k) blocks long.</pre>
<p>Now we encrypt it, using the default cipher we do not have to specify it explicitly. Note there is no option (yet) to double-check the passphrase before encryption starts, be careful not to mistype: 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup-reencrypt /dev/sdaX --new  --reduce-device-size 4096S</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
WARNING: this is experimental code, it can completely break your data.
Enter new passphrase: 
Progress: 100,0%, ETA 00:00, 2596 MiB written, speed  37,6 MiB/s</pre>
<p>After it finished, the encryption was performed to the full partition, i.e. not only the space the filesystem was shrunk to (<code>sdaX</code> has <code>2.6GiB</code> and the CPU used in the example has no hardware AES instructions). As a final step we extend the filesystem of the now encrypted device again to occupy available space: 
</p>
<pre># cryptsetup open /dev/sdaX recrypt 
Enter passphrase for /dev/sdaX: 
...
# resize2fs /dev/mapper/recrypt 
resize2fs 1.43-WIP (18-May-2015)
Resizing the filesystem on /dev/mapper/recrypt to 664807 (4k) blocks.
The filesystem on /dev/mapper/recrypt is now 664807 (4k) blocks long.
# mount /dev/mapper/recrypt /mnt</pre>
<p>and are done.
</p>
<h4><span class="mw-headline" id="Re-encrypting_an_existing_LUKS_partition">Re-encrypting an existing LUKS partition</span></h4>
<p>In this example an existing LUKS device is re-encrypted. 
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #FFDDDD; border: thin solid #DDBBBB; overflow: hidden;">
<strong> Warning: </strong>Double-check you specify encryption options for <i>cryptsetup-reencrypt</i> correctly and <i>never</i> re-encrypt without a <b>reliable backup</b>! As of September 2015 the tool <b>does</b> accept invalid options and damage the LUKS header, if not used correctly!</div>
<p>In order to re-encrypt a device with its existing encryption options, they do not need to be specified. A simple: 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup-reencrypt /dev/sdaX</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"> 
WARNING: this is experimental code, it can completely break your data.
Enter passphrase for key slot 0: 
Progress: 100,0%, ETA 00:00, 2596 MiB written, speed  36,5 MiB/s</pre>
<p>performs it. 
</p>
<p>A possible usecase is to re-encrypt LUKS devices which have non-current encryption options. Apart from above warning on specifying options correctly, the ability to change the LUKS header may also be limited by its size. For example, if the device was initially encrypted using a CBC mode cipher and 128 bit key-size, the LUKS header will be half the size of above mentioned <code>4096</code> sectors: 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksDump /dev/sdaX |grep -e "mode" -e "Payload" -e "MK bits"</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
Cipher mode:   	cbc-essiv:sha256
Payload offset:	<b>2048</b>
MK bits:       	128</pre>
<p>While it is possible to upgrade the encryption of such a device, it is currently only feasible in two steps. First, re-encrypting with the same encryption options, but using the <code>--reduce-device-size</code> option to make further space for the larger LUKS header. Second, re-encypt the whole device again with the desired cipher. For this reason and the fact that a backup should be created in any case, creating a new, fresh encrypted device to restore into is always the faster option.
</p>
<h2><span class="mw-headline" id="Keyfiles">Keyfiles</span></h2>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDDDFF; border: thin solid #BBBBDD; overflow: hidden;">
<strong> Note: </strong>This section describes using a plaintext keyfile. If you want to encrypt your keyfile giving you two factor authentication see <a href="../../en/Dm-crypt/Specialties.html#Using_GPG_or_OpenSSL_Encrypted_Keyfiles" title="Dm-crypt/Specialties">Using GPG or OpenSSL Encrypted Keyfiles</a> for details, but please still read this section.</div>
<p><b>What is a keyfile?</b>
</p>
<p>A keyfile is a file whose data is used as the passphrase to unlock an encrypted volume.
That means if such a file is lost or changed, decrypting the volume may no longer be possible.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;">
<strong> Tip: </strong>Define a passphrase in addition to the keyfile for backup access to encrypted volumes in the event the defined keyfile is lost or changed.</div>
<p><b>Why use a keyfile?</b>
</p>
<p>There are many kinds of keyfiles. Each type of keyfile used has benefits and disadvantages summarized below:
</p>
<h3><span class="mw-headline" id="Types_of_keyfiles">Types of keyfiles</span></h3>
<h4><span class="mw-headline" id="passphrase">passphrase</span></h4>
<p>This is a keyfile containing a simple passphrase. The benefit of this type of keyfile is that if the file is lost the data it contained is known and hopefully easily remembered by the owner of the encrypted volume. However the disadvantage is that this does not add any security over entering a passphrase during the initial system start.
</p>
<p>Example: 1234
</p>
<h4><span class="mw-headline" id="randomtext">randomtext</span></h4>
<p>This is a keyfile containing a block of random characters. The benefit of this type of keyfile is that it is much more resistant to dictionary attacks than a simple passphrase. An additional strength of keyfiles can be utilized in this situation which is the length of data used. Since this is not a string meant to be memorized by a person for entry, it is trivial to create files containing thousands of random characters as the key. The disadvantage is that if this file is lost or changed, it will most likely not be possible to access the encrypted volume without a backup passphrase.
</p>
<p>Example: fjqweifj830149-57 819y4my1-38t1934yt8-91m 34co3;t8y;9p3y-
</p>
<h4><span class="mw-headline" id="binary">binary</span></h4>
<p>This is a binary file that has been defined as a keyfile. When identifying files as candidates for a keyfile, it is recommended to choose files that are relatively static such as photos, music, video clips. The benefit of these files is that they serve a dual function which can make them harder to identify as keyfiles. Instead of having a text file with a large amount of random text, the keyfile would look like a regular image file or music clip to the casual observer. The disadvantage is that if this file is lost or changed, it will most likely not be possible to access the encrypted volume without a backup passphrase. Additionally, there is a theoretical loss of randomness when compared to a randomly generated text file. This is due to the fact that images, videos and music have some intrinsic relationship between neighboring bits of data that does not exist for a text file. However this is controversial and has never been exploited publicly.
</p>
<p>Example: images, text, video, ...
</p>
<h3><span class="mw-headline" id="Creating_a_keyfile_with_random_characters">Creating a keyfile with random characters</span></h3>
<h4><span class="mw-headline" id="Storing_the_keyfile_on_a_filesystem">Storing the keyfile on a filesystem</span></h4>
<p>A keyfile can be of arbitrary content and size. 
</p>
<p>Here <code>dd</code> is used to generate a keyfile of 2048 random bytes, storing it in the file <code>/etc/mykeyfile</code>:
</p>
<pre># dd bs=512 count=4 if=/dev/urandom of=/etc/mykeyfile iflag=fullblock
</pre>
<p>If you are planning to store the keyfile on an external device, you can also simply change the outputfile to the corresponding directory:
</p>
<pre># dd bs=512 count=4 if=/dev/urandom of=/media/usbstick/mykeyfile iflag=fullblock
</pre>
<h5><span class="mw-headline" id="Securely_overwriting_stored_keyfiles">Securely overwriting stored keyfiles</span></h5>
<p>If you stored your temporary keyfile on a physical storage device, and want to delete it, remember to not just remove the keyfile later on, but use something like
</p>
<pre># shred --remove --zero mykeyfile
</pre>
<p>to securely overwrite it. For overaged filesystems like FAT or ext2 this will suffice while in the case of journaling filesystems, flash memory hardware and other cases it is highly recommended to <a href="../../en/Securely_wipe_disk.html" title="Securely wipe disk">wipe the entire device</a> or at least the keyfiles partition.
</p>
<h4><span class="mw-headline" id="Storing_the_keyfile_in_tmpfs">Storing the keyfile in tmpfs</span></h4>
<p>Alternatively, you can mount a tmpfs for storing the keyfile temporarily:
</p>
<pre># mkdir mytmpfs
# mount tmpfs mytmpfs -t tmpfs -o size=32m
# cd mytmpfs
</pre>
<p>The advantage is that it resides in RAM and not on a physical disk, therefore it can not be recovered after unmounting the tmpfs. On the other hand this requires you to copy the keyfile to another filesystem you consider secure before unmounting.
</p>
<h3><span class="mw-headline" id="Configuring_LUKS_to_make_use_of_the_keyfile">Configuring LUKS to make use of the keyfile</span></h3>
<p>Add a keyslot for the keyfile to the LUKS header:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksAddKey /dev/sda2 /etc/mykeyfile</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
Enter any LUKS passphrase:
key slot 0 unlocked.
Command successful.</pre>
<h3><span class="mw-headline" id="Unlocking_a_secondary_partition_at_boot">Unlocking a secondary partition at boot</span></h3>
<p>If the keyfile for a secondary file system is itself stored inside an encrypted root, it is safe while the system is powered off but can be sourced to automatically unlock the mount during with boot via <a href="../../en/Dm-crypt/System_configuration.html#crypttab" title="Dm-crypt/System configuration">crypttab</a>. Following on from the first example above
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/crypttab</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">home    /dev/sda2    /etc/mykeyfile</pre>
<p>is all needed for unlocking, and 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/fstab</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">/dev/mapper/home        /home   ext4        defaults        0       2</pre> for mounting the LUKS blockdevice with the generated keyfile.
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;">
<strong> Tip: </strong>If you prefer to use a <code>--plain</code> mode blockdevice, the encryption options necessary to unlock it are specified in <code>/etc/crypttab</code>. Take care to apply the systemd workaround mentioned in <a href="../../en/Dm-crypt/System_configuration.html#crypttab" title="Dm-crypt/System configuration">crypttab</a> in this case.</div>
<h3><span class="mw-headline" id="Unlocking_the_root_partition_at_boot">Unlocking the root partition at boot</span></h3>
<p>This is simply a matter of configuring <a href="../../en/Mkinitcpio.html" title="Mkinitcpio">mkinitcpio</a> to include the necessary modules or files and configuring the <a href="../../en/Dm-crypt/System_configuration.html#cryptkey" title="Dm-crypt/System configuration">cryptkey</a> <a href="../../en/Kernel_parameters.html" title="Kernel parameters">kernel parameter</a> to know where to find the keyfile.
</p>
<p>Two cases will be covered:
</p>
<ol>
<li> Using a keyfile stored on an external media (here a USB stick)</li>
<li> Using a keyfile embedded in the initramfs </li>
</ol>
<h4><span class="mw-headline" id="With_a_keyfile_stored_on_an_external_media">With a keyfile stored on an external media</span></h4>
<h5><span class="mw-headline" id="Configuring_mkinitcpio">Configuring mkinitcpio</span></h5>
<p>You have to add two extra modules in your <code>/etc/mkinitcpio.conf</code>, one for the drive's file system (<code>vfat</code> module in the example below) and one for the codepage (<code>nls_cp437</code> module) :
</p>
<pre>MODULES="nls_cp437 vfat"
</pre>
<p>In this example it is assumed that you use a FAT formatted USB drive (<code>vfat</code> module). Replace those module names if you use another file system on your USB stick (e.g. <code>ext2</code>) or another codepage. Users running the stock Arch kernel should stick to the codepage mentioned here. If it complains of bad superblock and bad codepage at boot, then you need an extra codepage module to be loaded. For instance, you may need <code>nls_iso8859-1</code> module for <code>iso8859-1</code> codepage.
</p>
<p>If you have a non-US keyboard, it might prove useful to load your keyboard layout before you are prompted to enter the password to unlock the root partition at boot. For this, you will need the <code>keymap</code> hook before <code>encrypt</code>.
</p>
<p>Generate a new initramfs image:
</p>
<pre># mkinitcpio -p linux
</pre>
<h5><span class="mw-headline" id="Configuring_the_kernel_parameters">Configuring the kernel parameters</span></h5>
<p>Add the following options to the <a href="../../en/Kernel_parameters.html" title="Kernel parameters">kernel parameters</a> if using the <code>encrypt</code> hook. If using <code>sd-encrypt</code> see <a href="../../en/Dm-crypt/System_configuration.html#cryptkey" title="Dm-crypt/System configuration">Dm-crypt/System configuration#cryptkey</a>.
</p>
<pre>cryptdevice=/dev/<i>&lt;partition1&gt;</i>:root cryptkey=/dev/<i>&lt;partition2&gt;</i>:&lt;fstype&gt;:&lt;path&gt;
</pre>
<p>For example:
</p>
<pre>cryptdevice=/dev/sda3:root cryptkey=/dev/sdb1:vfat:/keys/secretkey
</pre>
<p>Choosing a plain filename for your key provides a bit of 'security through obscurity', but be aware the kernel command line is recorded in the kernel's log (<i>dmesg</i>). The keyfile can not be a hidden file, that means the filename must not start with a dot, or the <code>encrypt</code> hook will fail to find the keyfile during the boot process. Alternatively, one could hide the keyfile between the partitions and use:
</p>
<pre>cryptkey=/dev/sdb1:offset:size
</pre>
<p>As an advantage, it is harder to accidentally delete the key.
</p>
<p>The naming of device nodes like <code>/dev/sdb1</code> is not guaranteed to stay the same across reboots. It is more reliable to access the device with udev's <a href="../../en/Persistent_block_device_naming.html" title="Persistent block device naming">persistent block device naming</a> instead. To assure that the <code>encrypt</code> hook finds your keyfile when reading it from an external storage device, persistent block device names must be used. See the article <a href="../../en/Persistent_block_device_naming.html" title="Persistent block device naming">persistent block device naming</a>.
</p>
<h4><span class="mw-headline" id="With_a_keyfile_embedded_in_the_initramfs">With a keyfile embedded in the initramfs</span></h4>
<div style="padding: 5px; margin: 0.50em 0; background-color: #FFDDDD; border: thin solid #DDBBBB; overflow: hidden;">
<strong> Warning: </strong>Use an embedded keyfile <b>only</b> if you have some form of authentication mechanism beforehand that protects the keyfile sufficiently. Otherwise auto-decryption will occur, defeating completely the purpose of block device encryption.</div>
<p>This method allows to use a specially named keyfile that will be embedded in the <a href="../../en/Mkinitcpio.html" title="Initramfs" class="mw-redirect">initramfs</a> and picked up by the <code>encrypt</code> <a href="../../en/Mkinitcpio.html#HOOKS" title="Mkinitcpio">hook</a> to unlock the root filesystem (<code>cryptdevice</code>) automatically. It may be useful to apply when using the <a href="../../en/GRUB.html#Boot_partition" title="GRUB">GRUB early cryptodisk</a> feature, in order to avoid entering two passphrases during boot.
</p>
<p>The <code>encrypt</code> hook lets the user specify a keyfile with the <code>cryptkey</code> kernel parameter: in the case of initramfs, the syntax is <code>rootfs:<i>path</i></code>. See <a href="../../en/Dm-crypt/System_configuration.html#cryptkey" title="Dm-crypt/System configuration">Dm-crypt/System configuration#cryptkey</a>. Besides, this kernel parameter defaults to use <code>/crypto_keyfile.bin</code>, and if the initramfs contains a valid key with this name, decryption will occur automatically without the need to configure the <code>cryptkey</code> parameter.
</p>
<p>If using <code>sd-encrypt</code> instead of <code>encrypt</code>, specify the location of the keyfile with the <code>luks.cryptkey</code> kernel parameter. See <a href="../../en/Dm-crypt/System_configuration.html#luks.key" title="Dm-crypt/System configuration">Dm-crypt/System configuration#luks.key</a>.
</p>
<p><a href="#Creating_a_keyfile_with_random_characters">Generate the keyfile</a>, give it suitable permissions and <a href="#Adding_LUKS_keys">add it as a LUKS key</a>:
</p>
<pre># dd bs=512 count=4 if=/dev/urandom of=/crypto_keyfile.bin
# chmod 000 /crypto_keyfile.bin
# chmod 600 /boot/initramfs-linux*
# cryptsetup luksAddKey /dev/sdX# /crypto_keyfile.bin
</pre>
<div style="padding: 5px; margin: 0.50em 0; background-color: #FFDDDD; border: thin solid #DDBBBB; overflow: hidden;">
<strong> Warning: </strong>When initramfs' permissions are set to 644 (by default), then all users will be able to dump the keyfile. Make sure the permissions are still 600 if you install a new kernel.</div>
<p>Include the key in <a href="../../en/Mkinitcpio.html#BINARIES_and_FILES" title="Mkinitcpio">mkinitcpio FILES array</a>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mkinitcpio.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">FILES="/crypto_keyfile.bin"</pre>
<p>Finally <a href="../../en/Mkinitcpio.html#Image_creation_and_activation" title="Mkinitcpio">Regenerate your initramfs</a>.
</p>
<p>On the next reboot you should only have to enter your container decryption passphrase once.
</p>
<p>(<a rel="nofollow" class="external text" href="http://www.pavelkogan.com/2014/05/23/luks-full-disk-encryption/#bonus-login-once">source</a>)
</p>
</div>
<div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../../Special:Categories.html" title="Special:Categories">Categories</a>: <ul>
<li><a href="../../en/Category:Encryption.html" title="Category:Encryption">Encryption</a></li>
<li><a href="../../en/Category:File_systems.html" title="Category:File systems">File systems</a></li>
</ul>
</div></div>					<div class="visualClear"></div>
				</div>
			</div>
		</div>
		<div class="visualClear"></div>
					<div id="footer" role="contentinfo">
						<ul id="f-list" style="margin: 0 2em">
									<li>
Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=Dm-crypt/Device_encryption&amp;oldid=452489">https://wiki.archlinux.org/index.php?title=Dm-crypt/Device_encryption&amp;oldid=452489</a>"</li>
					<li id="lastmod"> This page was last modified on 30 September 2016, at 16:31.</li>
									<li id="copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
									<br><li id="privacy"><a href="../../en/ArchWiki:General_disclaimer.html" title="ArchWiki:Privacy policy">Privacy policy</a></li>
									<li id="about"><a href="../../en/ArchWiki:About.html" title="ArchWiki:About">About ArchWiki</a></li>
									<li id="disclaimer"><a href="../../en/ArchWiki:General_disclaimer.html" title="ArchWiki:General disclaimer">Disclaimers</a></li>
							</ul>
		</div>
		</div>
		</body>
</html>
